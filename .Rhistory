)
)
finite.difference <- function(x, y, i, j){
cat(i)
cat(j)
cat('temperature')
cat(y[i])
cat(y[j])
cat('\ntime difference')
cat(x[i])
cat(x[j])
cat(difftime(x[j], x[i], units = "secs"))
return(
(y[j]-y[i]) / as.numeric(difftime(x[i], x[j], units = "secs")
)
)
}
approx.derivative <- function(x, y) {
if (length(x) != length(y)) {
stop('x and y vectors must have equal length')
}
n <- length(x)
# Initialize a vector of length n to enter the derivative approximations
fdx <- vector(length = n)
# Iterate through the values using the forward differencing method
for (i in 2:n-1) {
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
}
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
# Iterate through the values using the forward differencing method
for (i in 2:n-1) {
cat(i)
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
approx.derivative <- function(x, y) {
if (length(x) != length(y)) {
stop('x and y vectors must have equal length')
}
n <- length(x)
# Initialize a vector of length n to enter the derivative approximations
fdx <- vector(length = n)
# Iterate through the values using the forward differencing method
for (i in 2:n-1) {
cat(i)
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
}
return(fdx)
```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
finite.difference <- function(x, y, i, j){
cat(i)
cat(j)
cat('temperature')
cat(y[i])
cat(y[j])
cat('\ntime difference')
cat(x[i])
cat(x[j])
cat(difftime(x[j], x[i], units = "secs"))
return(
(y[j]-y[i]) / as.numeric(difftime(x[i], x[j], units = "secs")
)
)
}
return(fdx)
```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
length(df.list$Timestamp)
finite.difference <- function(x, y, i, j){
return(
(y[j]-y[i]) / as.numeric(difftime(x[i], x[j], units = "secs")
)
)
}
approx.derivative <- function(x, y) {
if (length(x) != length(y)) {
stop('x and y vectors must have equal length')
}
n <- length(x)
# Initialize a vector of length n to enter the derivative approximations
fdx <- vector(length = n)
# Iterate through the values using the forward differencing method
for (i in seq(2,n-1)) {
cat(i)
cat('\n')
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
}
return(fdx)
```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
rm(list = ls())
finite.difference <- function(x, y, i, j){
return(
(y[j]-y[i]) / as.numeric(difftime(x[i], x[j], units = "secs")
)
)
}
approx.derivative <- function(x, y) {
if (length(x) != length(y)) {
stop('x and y vectors must have equal length')
}
n <- length(x)
# Initialize a vector of length n to enter the derivative approximations
fdx <- vector(length = n)
# Iterate through the values using the forward differencing method
for (i in seq(2,n-1)) {
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
}
return(fdx)
```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
df.list$diff_BME680_T <- approx.derivative(df.list$Timestamp, df.list$BME680_T)
segm.list <- segm.list %>%
select(filter_state, StartTime, StopTime, roast, testID, last_clean)
load(segm.file)
load(measurement.file)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
df.list$diff_BME680_T <- approx.derivative(df.list$Timestamp, df.list$BME680_T)
rm(list = ls())
finite.difference <- function(x, y, i, j){
return(
(y[j]-y[i]) / as.numeric(difftime(x[i], x[j], units = "secs")
)
)
}
approx.derivative <- function(x, y) {
if (length(x) != length(y)) {
stop('x and y vectors must have equal length')
}
n <- length(x)
# Initialize a vector of length n to enter the derivative approximations
fdx <- vector(length = n)
# Iterate through the values using the forward differencing method
for (i in seq(2,n-1)) {
fdx[i] <- finite.difference(x, y, i-1, i+1)
}
# For the last value, since we are unable to perform the forward differencing method
# as only the first n values are known, we use the backward differencing approach
# instead. Note this will essentially give the same value as the last iteration
# in the forward differencing method, but it is used as an approximation as we
# don't have any more information
fdx[1] <- finite.difference(x, y, 1, 2)
fdx[n] <- finite.difference(x, y, n-1, n)
return(fdx)
}
return(fdx)
```{r setup, include=FALSE}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(plotly)
library(flexdashboard)
library(kableExtra)
library(DT)
knitr::opts_chunk$set(echo = FALSE)
Verhaert_green <- '#7AC143'
Verhaert_darkblue <- '#002339'
Verhaert_grey <- '#9DA2B5'
Verhaert_lightgrey <- '#DCDFE7'
Verhaert_blue <- '#3CADB5'
Verhaert_red <- '#DA3330'
Verhaert_yellow <- '#FFCD4E'
folder <- 'Data/Endurance data'
segm.file <- file.path(folder, 'segments.rda')
measurement.file <- file.path(folder, 'Measurements.rda')
load(segm.file)
load(measurement.file)
df.list <- df.list %>%
select(Timestamp, DS1820, BME680_T, Errors, roast, testID, last_clean, since_clean)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
df.list$diff_DS1820 <- approx.derivative(df.list$Timestamp, df.list$DS1820)
df.list$diff_BME680_T <- approx.derivative(df.list$Timestamp, df.list$BME680_T)
segm.list <- segm.list %>%
select(filter_state, StartTime, StopTime, roast, testID, last_clean)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/GermanTanks.R', echo=TRUE)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/GermanTanks.R', echo=TRUE)
rm(list = ls())
prior <- dunif(x = 1/1000, min = 1, max = 1000)
prior <- dunif(x = 1:1000, min = 1, max = 1000)
?rrpois
?rpois
A <- data.frame()
A$lambda <- seq(0.5,3, by = 0.5)
?data.frame
A <- seq(0.5,3, by = 0.5)
A <- data.frame()
A <- seq(0.5,3, by = 0.5)
data.frame(A)
data.frame(lambda = A)
source('~/.active-rstudio-document', echo=TRUE)
?dpois
dpois(1, 2)
dpois(2, 2)
dpois(3, 2)
dpois(10, 2)
dpois(0, 2)
dpois(12, 6 * t$lambda)
t$posterior <- t$PriorXLikelyhood / sum(t$PriorXLikelyhood)
source('~/.active-rstudio-document', echo=TRUE)
View(t)
dpois(12, 6 * 2)
sapply(t$lambda, function(x) dpois(12, 6 * x))
View(t)
View(t)
plot(t$lambda, t$prior)
plot(t$lambda, t$posterior)
source('~/.active-rstudio-document', echo=TRUE)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/trucks.R', echo=TRUE)
?dnorm
rm(list = ls())
observed_snow <- c(19.4, 21.2, 29)
sd <- 5
s <- data.frame(mu = seq(10, 35, by = 5))
s$prior <- c(10, 15, 25, 25, 15, 10) / 100
plot(s$mu, s$prior)
calc.posterior <- function(prior, obs){
likelyhood <- dnorm(obs, mean = s$mu, sd = sd)
priorXlikelyhood <- s$prior * likelyhood
priorXlikelyhood / sum(priorXlikelyhood)
}
for(obs in observed_snow){
s$prior <- calc.posterior(s$prior, obs)
}
plot(s$mu, s$prior)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/trucks.R', echo=TRUE)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/trucks.R', echo=TRUE)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/trucks.R', echo=TRUE)
source('D:/User/jalexander/Workspace/mastat/Bayesian statistics/Les3/trucks.R', echo=TRUE)
install.packages("expm")
# Calculate intervals
format <- '%Y-%m-%d %H:%M'
switchdates <- c(paste0('2020-02-', c('18', '20', '25'), ' 00:00'), '2020-03-02 00:00')
events <- c(runs$start, runs$stop, as.POSIXct(switchdates, format = format))
switchdates <- c(paste0('2020-02-', c('18', '20', '25'), ' 00:00'), '2020-03-02 00:00')
events <- c(runs$start, runs$stop, as.POSIXct(switchdates, format = format))
as.POSIXct(switchdates, format = format)
library('installr')
updateR()
rm(list = ls())
rm(list = ls())
library(latex2exp)
rm(list = ls())
library(latex2exp)
library(tidyverse)
library(boot)
library(latex2exp)
library(tidyverse)
library(boot)
library(PMA)
library(pls)
library(MASS)
library(glmnet)
library(ROCR)
#library(multtest)
library(RDRToolbox)
# Introduction
The data is loaded as presented in the assignment. The data is loaded as the raw dataset, the centered dataset and the standardized dataset.
Three research questions are defined:
* How do the 54675 genes vary in terms of their gene expression levels? Is the variability associated with kidney rejection? (only to be answered in a data explorative manner).
* Which genes are differentially expressed between the two kidney rejection groups? You must control the False Discovery Rate at 10%.
* Can the kidney rejection be predicted from the gene expressions? What genes are most important in predicting the kidney transplant rejection? How well does the prediction model perform in terms of predicting rejection status?
# Data exploration
In the complete dataset, `r round(mean(RejectionStatus$Reject_Status) * 100) ` % of the transplanted kidnesy were rejected.
## Simple plot of the raw data
Before plotting dimension reduced representations of the data, a simple plot of the raw data is made. (insert Stevens code)
```{r}
df <- tibble(patient = RejectionStatus$Patient_ID,
reject = ifelse(RejectionStatus$Reject_Status == 1, "Rejected", "Accepted"),
as.data.frame(GeneExpression_C)) %>%
pivot_longer(cols = c(-reject,-patient) , names_to = "gene", values_to = "expression")
# calculate summaries
df %>%
group_by(reject, gene) %>%
summarise(mean = mean(expression),
sd = sd(expression),
min = min(expression),
max = max(expression),
median = median(expression),
iqr = IQR(expression)) -> basics
library(latex2exp)
library(tidyverse)
library(boot)
library(PMA)
library(pls)
library(MASS)
library(glmnet)
library(ROCR)
#library(multtest)
library(RDRToolbox)
library(diffusionMap)
library(diffusionMap)
library(car)
library(diffusionMap)
library(car)
library(sgof)
library(tsne)
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)
set.seed(321)
set.seed(321)
```{r load data, eval=TRUE, include=TRUE}
load('RejectionStatus.rda')
load('X_GSE21374.rda')
dim(RejectionStatus)
dim(X_GSE21374)
GeneExpression <- t(X_GSE21374)
GeneExpression_C <- scale(t(X_GSE21374),scale = F)
GeneExpression_C <- scale(t(X_GSE21374),scale = F)
GeneExpression_S <- scale(t(X_GSE21374),scale = T)
GeneExpression <-
GeneExpression[order(as.numeric(row.names(GeneExpression))), ]
RejectionStatus <-
RejectionStatus[order(as.numeric(RejectionStatus$Patient_ID)), ]
all.equal(row.names(GeneExpression), as.character(RejectionStatus$Patient_ID))
all.equal(row.names(GeneExpression), as.character(RejectionStatus$Patient_ID))
# Introduction
The data is loaded as presented in the assignment. The data is loaded as the raw dataset, the centered dataset and the standardized dataset.
Three research questions are defined:
* How do the 54675 genes vary in terms of their gene expression levels? Is the variability associated with kidney rejection? (only to be answered in a data explorative manner).
* Which genes are differentially expressed between the two kidney rejection groups? You must control the False Discovery Rate at 10%.
* Can the kidney rejection be predicted from the gene expressions? What genes are most important in predicting the kidney transplant rejection? How well does the prediction model perform in terms of predicting rejection status?
# Data exploration
In the complete dataset, `r round(mean(RejectionStatus$Reject_Status) * 100) ` % of the transplanted kidnesy were rejected.
## Simple plot of the raw data
Before plotting dimension reduced representations of the data, a simple plot of the raw data is made. (insert Stevens code)
```{r}
df <- tibble(patient = RejectionStatus$Patient_ID,
reject = ifelse(RejectionStatus$Reject_Status == 1, "Rejected", "Accepted"),
as.data.frame(GeneExpression_C)) %>%
pivot_longer(cols = c(-reject,-patient) , names_to = "gene", values_to = "expression")
df <- tibble(patient = RejectionStatus$Patient_ID,
reject = ifelse(RejectionStatus$Reject_Status == 1, "Rejected", "Accepted"),
as.data.frame(GeneExpression_C)) %>%
pivot_longer(cols = c(-reject,-patient) , names_to = "gene", values_to = "expression")
# calculate summaries
df %>%
group_by(reject, gene) %>%
summarise(mean = mean(expression),
sd = sd(expression),
min = min(expression),
max = max(expression),
median = median(expression),
iqr = IQR(expression)) -> basics
