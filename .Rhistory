max.n.comps <- 5 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U%*%D
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.25)}, K = 10)$delta[1]
}
npc.min <- which.min(cv.glm.pcr)
plot(1:max.n.comps, cv.glm.pcr, type = "l")
abline(v=npc.min, col =2)
seq(15, 50, 5)
seq(20, 50, 10)
for (j in seq(20, 50, 10)){
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = j/100)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
}
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U%*%D
for (j in seq(20, 50, 10)){
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = j/100)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
}
V <- X_train.svd$v
Z_test <- X_test %*% V
fitdata <- data.frame(Y_train, Z_train[,1:npc.min])
mod <- glm(Y_train ~ ., data = fitdata)
preddata <- data.frame(Z_test[,1:npc.min])
pred_mod <- prediction(predict(mod, newdata = preddata), Y_test)
perf_mod <- performance(pred_mod, "sens", "fpr")
plot(perf_mod)
plot(perf_mod)
AUC is `r performance(pred_mod, "auc")@y.values`.
## Principal component regression
```{r PCR CV}
# cost function for CV
MISERR <- function(obs, pred, cutoff = 0.35){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U%*%D
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.45)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.35)}, K = 10)$delta[1]
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.35)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.25)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.6)}, K = 10)$delta[1]
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.6)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
for(i in 1:max.n.comps){
fitdata <- data.frame(Y_train, Z_train[,1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <- cv.glm(fitdata, mod, cost = {function (obs, pred) MISERR(obs, pred, cutoff = 0.7)}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min <- which.min(cv.glm.pcr)
abline(v=npc.min, col =2)
```{r PCR model}
V <- X_train.svd$v
Z_test <- X_test %*% V
fitdata <- data.frame(Y_train, Z_train[,1:npc.min])
mod <- glm(Y_train ~ ., data = fitdata)
preddata <- data.frame(Z_test[,1:npc.min])
pred_mod <- prediction(predict(mod, newdata = preddata), Y_test)
perf_mod <- performance(pred_mod, "sens", "fpr")
plot(perf_mod)
# cost function for CV
MISERR <- function(obs, pred, cutoff = 0.5){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
npc.min <- rep(NA, 9)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U %*% D
for (j in seq(1, 9)) {
for (i in 1:max.n.comps) {
fitdata <- data.frame(Y_train, Z_train[, 1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <-
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min[j] <- which.min(cv.glm.pcr)
abline(v = npc.min[j], col = 2)
}
npc.min
# cost function for CV
MISERR <- function(obs, pred, cutoff = 0.5){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
npc.min <- rep(NA, 9)
npc.val <- rep(NA, 9)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U %*% D
for (j in seq(1, 9)) {
for (i in 1:max.n.comps) {
fitdata <- data.frame(Y_train, Z_train[, 1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <-
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min[j] <- which.min(cv.glm.pcr)
npc.val[j] <- cv.glm.pcr[npc.min[j]]
abline(v = npc.min[j], col = 2)
}
npc.min
npc.val
r performance(pred_mod, "auc")@y.values
performance(pred_mod, "auc")@y.values
V <- X_train.svd$v
Z_test <- X_test %*% V
fitdata <- data.frame(Y_train, Z_train[,1:npc.min])
mod <- glm(Y_train ~ ., data = fitdata)
preddata <- data.frame(Z_test[,1:npc.min])
pred_mod <- prediction(predict(mod, newdata = preddata), Y_test)
perf_mod <- performance(pred_mod, "sens", "fpr")
plot(perf_mod)
plot(perf_mod)
performance(pred_mod, "auc")@y.values
# cost function for CV
MISERR <- function(obs, pred, cutoff = 0.5){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
npc.min <- rep(NA, 9)
npc.val <- rep(NA, 9)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U %*% D
for (j in seq(1, 9)) {
for (i in 1:max.n.comps) {
fitdata <- data.frame(Y_train, Z_train[, 1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <-
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min[j] <- which.min(cv.glm.pcr)
npc.val[j] <- cv.glm.pcr[npc.min[j]]
abline(v = npc.min[j], col = 2)
}
npc.m <- npc.min[which.min(npc.val)]
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min[j] <- which.min(cv.glm.pcr)
npc.val[j] <- cv.glm.pcr[npc.min[j]]
abline(v = npc.min[j], col = 2)
}
npc.m <- npc.min[which.min(npc.val)]
```{r PCR model}
V <- X_train.svd$v
Z_test <- X_test %*% V
fitdata <- data.frame(Y_train, Z_train[,1:npc.m])
mod <- glm(Y_train ~ ., data = fitdata)
preddata <- data.frame(Z_test[,1:npc.m])
pred_mod <- prediction(predict(mod, newdata = preddata), Y_test)
perf_mod <- performance(pred_mod, "sens", "fpr")
plot(perf_mod)
performance(pred_mod, "auc")@y.values
install.packages("locfdr")
rm(list = ls())
library(latex2exp)
library(tidyverse)
library(boot)
library(PMA)
library(pls)
library(MASS)
library(glmnet)
library(ROCR)
#library(multtest)
#library(RDRToolbox)
library(diffusionMap)
library(car)
library(sgof)
library(tsne)
library(locfdr)
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)
set.seed(321)
set.seed(321)
```{r load data, eval=TRUE, include=TRUE}
load('RejectionStatus.rda')
load('X_GSE21374.rda')
dim(RejectionStatus)
dim(X_GSE21374)
GeneExpression <- t(X_GSE21374)
GeneExpression_C <- scale(t(X_GSE21374),scale = F) # centered
GeneExpression_S <- scale(t(X_GSE21374),scale = T) # scaled
GeneExpression <-
GeneExpression[order(as.numeric(row.names(GeneExpression))), ]
RejectionStatus <-
RejectionStatus[order(as.numeric(RejectionStatus$Patient_ID)), ]
all.equal(row.names(GeneExpression), as.character(RejectionStatus$Patient_ID))
all.equal(row.names(GeneExpression), as.character(RejectionStatus$Patient_ID))
# Introduction
The data is loaded as presented in the assignment. The data is loaded as the raw dataset, the centered dataset and the standardized dataset.
Three research questions are defined:
* How do the 54675 genes vary in terms of their gene expression levels? Is the variability associated with kidney rejection? (only to be answered in a data explorative manner).
* Which genes are differentially expressed between the two kidney rejection groups? You must control the False Discovery Rate at 10%.
* Can the kidney rejection be predicted from the gene expressions? What genes are most important in predicting the kidney transplant rejection? How well does the prediction model perform in terms of predicting rejection status?
# Data exploration
In the complete dataset, `r round(mean(RejectionStatus$Reject_Status) * 100) ` % of the transplanted kidnesy were rejected.
## Descriptives
Several descriptive statistics (mean, sd, median, iqr, min, and max) were calculated for every gene and kidney rejection status combination. This resulted in 2 (accepted vs. rejected) distributions of those statistics across genes. Note that these statistics were only calculated to perform a visual inspection. The resulted plot is presented in figure \ref{descriptives}. From this figure we can see there are, at least on this level, differences between groups. Most notable are the mean and median expression levels which tend to be more centered around the overall (across groups) mean expression levels in the _accepted_ group and more varying in the _rejected_ group. There seems to be more variablity in the measures of dispersion in the _rejected_ group. Finally there are minimal differences between the min/max expression level distributions, perhaps suggesting that gene expression levels in the _rejected_ group are slightly less extreme than in the _accepted_ group.
```{r descriptives, fig.cap="Descriptive statistics across grenes and between groups. Note that the data were centered before calculating the statistics."}
df <- tibble(patient = RejectionStatus$Patient_ID,
reject = ifelse(RejectionStatus$Reject_Status == 1, "Rejected", "Accepted"),
as.data.frame(GeneExpression_C)) %>%
pivot_longer(cols = c(-reject,-patient) , names_to = "gene", values_to = "expression")
# calculate summaries
df %>%
group_by(reject, gene) %>%
summarise(mean = mean(expression),
sd = sd(expression),
min = min(expression),
max = max(expression),
median = median(expression),
iqr = IQR(expression)) -> basics
# long format
basics %>%
pivot_longer(-c(reject, gene), names_to = "statistic", values_to = "value") -> basics_long
# fix order of statistics for plot facet
basics_long %>%
mutate(statistic = factor(statistic, levels = c("mean", "sd", "min",
"median", "iqr", "max"))) -> basics_long
# plot
ggplot(basics_long, aes(value, fill = reject)) +
geom_density(alpha = 0.5) +
theme_classic() +
labs(fill = "Status") +
facet_wrap("statistic", scales = "free" ) +
scale_fill_manual(values = c("#4DBBD5", "#E64B35"))
## Sparse principle components analysis
rm(list = ls())
library(latex2exp)
library(tidyverse)
library(boot)
library(PMA)
library(pls)
library(MASS)
library(glmnet)
library(ROCR)
#library(RDRToolbox)
library(diffusionMap)
library(car)
library(sgof)
library(tsne)
library(locfdr)
knitr::opts_chunk$set(echo = TRUE, fig.width=6, fig.height=4)
set.seed(321)
load('RejectionStatus.rda')
load('X_GSE21374.rda')
dim(RejectionStatus)
dim(X_GSE21374)
GeneExpression <- t(X_GSE21374)
GeneExpression_C <- scale(t(X_GSE21374),scale = F) # centered
GeneExpression_S <- scale(t(X_GSE21374),scale = T) # scaled
GeneExpression <-
GeneExpression[order(as.numeric(row.names(GeneExpression))), ]
RejectionStatus <-
RejectionStatus[order(as.numeric(RejectionStatus$Patient_ID)), ]
all.equal(row.names(GeneExpression), as.character(RejectionStatus$Patient_ID))
ind_train <-
sample(seq_len(nrow(RejectionStatus)), size = floor(nrow(RejectionStatus) * 0.70))
Y_train <- as.matrix(RejectionStatus[ind_train, 'Reject_Status'])
X_train <- as.matrix(GeneExpression_C[ind_train,])
Y_test <- as.matrix(RejectionStatus[-ind_train, 'Reject_Status'])
X_test <- as.matrix(GeneExpression_C[-ind_train,])
m.cv <-
cv.glmnet(
x = X_train,
y = Y_train,
alpha = 1,
family = 'binomial',
type.measure = "auc"
)
plot(m.cv, xlab = TeX(" $ log(\\gamma ) $ "))
m.cv$lambda.min
m <- glmnet(
x = X_train,
y = Y_train,
alpha = 1,
family = 'binomial',
lambda = m.cv$lambda.min
)
pred_m <-
prediction(predict(
m,
newx = X_test,
type = 'response'
),
Y_test)
perf <- performance(pred_m, 'sens', 'fpr')
plot(perf)
length(unique(summary(coef(m))[-1,1]))
plot(
summary(coef(m))[-1, 1],
summary(coef(m))[-1, 3],
cex = 1,
pch = 3,
xlab = 'gene index' ,
ylab = TeX(" $ \\hat{\\beta} $ ")
)
m <- glmnet(
x = X_train,
y = Y_train,
alpha = 1,
family = 'binomial',
lambda = m.cv$lambda.min
)
pred_m <-
prediction(predict(
m,
newx = X_test,
type = 'response'
),
Y_test)
perf <- performance(pred_m, 'sens', 'fpr')
plot(perf)
m.cv <-
cv.glmnet(
x = X_train,
y = Y_train,
alpha = 1,
family = 'binomial',
type.measure = "auc"
)
m <- glmnet(
x = X_train,
y = Y_train,
alpha = 1,
family = 'binomial',
lambda = m.cv$lambda.min
)
pred_m <-
prediction(predict(
m,
newx = X_test,
type = 'response'
),
Y_test)
plot(m.cv, xlab = TeX(" $ log(\\gamma ) $ "))
performance(pred_m, "auc")@y.values
m.cv <-
cv.glmnet(
x = X_train,
y = Y_train,
alpha = 0,
family = 'binomial',
type.measure = "auc"
)
m <- glmnet(
x = X_train,
y = Y_train,
alpha = 0,
family = 'binomial',
lambda = m.cv$lambda.min
)
pred_m <-
prediction(predict(
m,
newx = X_test,
type = 'response'
),
Y_test)
plot(m.cv, xlab = TeX(" $ log(\\gamma ) $ "))
performance(pred_m, "auc")@y.values
MISERR <- function(obs, pred, cutoff = 0.5){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
npc.min <- rep(NA, 9)
npc.val <- rep(NA, 9)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U %*% D
for (j in seq(1, 9)) {
for (i in 1:max.n.comps) {
fitdata <- data.frame(Y_train, Z_train[, 1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <-
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1]
}
plot(1:max.n.comps, cv.glm.pcr, type = "l")
npc.min[j] <- which.min(cv.glm.pcr)
npc.val[j] <- cv.glm.pcr[npc.min[j]]
abline(v = npc.min[j], col = 2)
}
npc.m <- npc.min[which.min(npc.val)]
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1]
?cv.glm
mod
npc.m <- npc.min[which.min(npc.val)]
plot(1:max.n.comps, cv.glm.pcr, type = "l")
cv.glm.pcr
?plot
# cost function for CV
MISERR <- function(obs, pred, cutoff = 0.5){
ypred <- as.numeric(pred > cutoff)
tab <- table(obs, ypred)
miserr <- 1 - sum(diag(tab))/sum(tab)
return(miserr)
}
max.n.comps <- 50 #random nr
cv.glm.pcr <- rep(NA, max.n.comps)
npc.min <- rep(NA, 9)
npc.val <- rep(NA, 9)
X_train.svd <- svd(X_train)
U <- X_train.svd$u
D <- diag(X_train.svd$d)
Z_train <- U %*% D
for (j in seq(1, 9)) {
for (i in 1:max.n.comps) {
fitdata <- data.frame(Y_train, Z_train[, 1:i])
mod <- glm(Y_train ~ ., data = fitdata, family = "binomial")
cv.glm.pcr[i] <-
cv.glm(fitdata, mod, cost = {
function (obs, pred)
MISERR(obs, pred, cutoff = j/10)
}, K = 10)$delta[1] # test cutoff-value of 0.1 to 0.9
}
plot(1:max.n.comps, cv.glm.pcr, type = "l", main = paste("cutoff value", j))
npc.min[j] <- which.min(cv.glm.pcr)
npc.val[j] <- cv.glm.pcr[npc.min[j]]
abline(v = npc.min[j], col = 2)
}
npc.m <- npc.min[which.min(npc.val)]
